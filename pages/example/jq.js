$(this) // относится к элементу страницы, к которому прикреплено событие. стр.218
toggleClass() // добавляет класс, если он еще не применен к элементу, и удаляет его, если он применен
replaceWith() // заменяет выбранный элемент любым HTML-кодом, который вы ему передаете. стр.315
hover() /*принимает два аргумента: первый — это функция, сообщающая браузеру, что делать, когда указатель мыши наведен
на картинку; второй — это функция, сообщающая браузеру, что делать, если указатель смещается с изображения.*/

each() /* обеспечивает быстрый способ проработки в цикле группы элементов
страницы, осуществляя над каждым из элементов серию действий. стр.216 */
/* Чтобы использовать функцию each (), вы передаете ей особый
аргумент — анонимную функцию. Она содержит действия, которые вы
хотите выполнить над каждым элементом. */
$('selector').each(function() {
	// инструкции поочередно будут применяться к каждому элементу
});

attr() // возвращает значение атрибута. стр.215
var imageFile = $('.banner img').attr('src'); // imageFile - будет содержать путь к изображению (images/banner.png)
// Передавая второй аргумент функции attг(), вы можете установить атрибут элемента.
$('banner img').attr('src', 'images/newimage.png');

removeAttr(); // удаляет атрибут
$('body').removeAttr('bgColor'); // удаляет свойство bgColor из элемента body


// === Обход дерева DOM === стр.742
.find() // Функция используется для поиска потомков (элементов, размещенных в теле другого элемента) в существующей выборке.
$('.gallery').find('img') // код выполняет поиск всех изображений (с разной вложенностью) в элементе с классом .gallery

.children() /* похожа на функцию .find(). Она также принимает в качестве аргумента селектор, но выполняет поиск
лишь в наборе непосредственных потомков текущей выборки. */
$('.container').click(function(){
	$(this).children('div').show().css('outline', 'red 2px solid');
});
/* Код .find('div') выберет абсолютно все элементы div, в том числе и содержащиеся в других элементах.
/* Код .children('div') выберет лишь непосредственные дочерние элементы
основного элемента div и пропустит любые элементы, размещенные внутри дочерних элементов div. */

.parent() // перемещается по дереву DOM в поисках родителя текущего элемента

.closest() // находит ближайшего предка, удовлетворяющего заданному селектору
/* В отличие от функции .parent(), которая выбирает непосредственного родителя текущего элемента, 
функция .closest() принимает в качестве аргумента селектор и находит ближайшего предка, соответствующего этому селектору */

.siblings() // пригодится в случаях, когда нужно выбрать элемент, который находится на одном уровне с уже выбранным.

.next() // находит следующий элемент того же уровня в текущей выборке

.prev() // действует так же, как и функция .next(), но ищет ближайший предшествующий элемент того же уровня.


// === функции для работы с кодом HTML ===
.text() // заменяет текстовое содержимое выбранных элементов выборкой, переданной ей в качестве аргумента.
// Например:
$('.error').text('Укажите адрес электронной почты');

.html() // действует так же, как функция .text(), но вставляется не текстовая строка, а код HTML:
	$('.tooltip').html('<h2>>Модель Avalon компании Esquif</h2><p>Предназначена для путешествий на каноэ.</p>');

.append() // добавляет код HTML в конец элемента
.prepend() // добавляет код HTML в начало элемента
.before() // вставляет заданное содержимое перед элементами выборки.
.after() // вставляет указанное содержимое после элементов выборки


// ===  функции для удаления содержимого страницы: ===
.replaceWith() // полностью заменяет выбранные элементы (тег и все, что внутри) содержимым, полученным в качестве аргумента
.remove() // удаляет выбранные элементы из модели DOM, фактически удаляя их со страницы.

.wrap() // заключает каждый элемент выборки в пару HTML-тегов. 
.wrapInner() // окружает HTML-элементами содержимое каждого элемента выборки.
.unwrap() /* удаляет родительский элемент, окружающий выборку.
функция .unwrap() не принимает аргументов — другими словами, не помещайте ничего
в круглых скобках функции .unwrap(), иначе она не будет работать */
.empty() // удалит все содержимое элементов выборки, но сама выборка при этом останется (не принимает аргументов).





$('a').mouseover(); // событие наведения указателя мыши
$('a').mouseout(); // событие смещения указателя мыши
$('a').click(); // событие щелчка мыши
$('a').dblclick(); // событие двойного щелчка мыши

$('a').css('color','red'); // добавление стилей css


/*==== .hover() ====
События наведения и смещения указателя мыши
*/
$('a').hover(); //  реакции на события наведения и смещения курсора (краткий метод применения событий mouseenter и mouseleave к элементу. )
$('#селектор').hover(функция1, функция2);

// длинная запись
function showSubmenu() {
	$('#submenu').show();
}
function hideSubmenu() {
	$('#submenu').hide();
}
$('#menu').hover(showSubmenu, hideSubmenu);

// сокращённая запись
$('#menu').hover(function(){
	$('#submenu').show();
}, function(){
	$('#submenu').hide();
});

// Объект события, event - событие (e, evt, event)
$(document).click(function(e){
	var xPos = e.pageX;
	var yPos = e.pageY;
	alert('X: ' + xPos + ' Y: ' + yPos);
});

// Отмена обычного поведения событий
preventDefault();

// === Удаление событий ===
off(); //удаляет все события

$('#disable').click(function(){
	$('a').off('mouseover'); // удаляет событие наведения мыши mouseover
})

// Библиотека jQuery предлагает функцию stopPropagation(), препятствующую присвоению события любому элементу-предку
stopPropagation();
$('#theLink').click(function(e){
	// некие действия
	e.stopPropagation(); // останавливает событие
});


/*
Метод on() — это более гибкий способ работы с событиями по сравнению со специфичными jQuery-функциями, такими как click() или
mouseover(). Он позволяет не только указывать событие и функцию
для реакции на него, но и передавать дополнительные данные для использования функцией, обрабатывающей событие.
*/
/*
ПРИМЕЧАНИЕ
По мере развития библиотеки jQuery имена функций, используемых для добавления и удаления событий с элементов, сильно изменились. При чтении более ранних изданий данной книги или
блогов вы можете наткнуться на такие функции, как bind() ,live() и delegate(). 
Все они были заменены одной функцией on(), предназначенной для добавления событий к элементам. Кроме того,
функция off() заменила функцию unbind(), которая использовалась для удаления событий с элементов.
*/
// Формат функции on () следующий:
$('# селектор').on ('событиемыши', селектор, данные, имяфункции);
/* ПРИМЕЧАНИЕ
Передача данных при использовании функции on() не является обязательной. 
Если вы хотите использовать функцию on(), просто чтобы присоединить событие и функцию, опустите аргумент с данными:
$ ('селектор').on ('событиемыши', имяфункции) ;
Функционально данный код идентичен следующему:
$('селектор').click(имяфункции); */
var linkVar = {message: 'Привет от ссылки'};
var pVar = {message: 'Привет от абзаца'};
function showMessage(e){
	alert(e.data.message);
}
$('a').on('mouseover',linkVar,showMessage);
$('p').on('click',pVar,showMessage);


$(document).on('click keypress', function(){
	$(#lightbox).hide();
});
/* Важная часть кода здесь — это 'click keypress'. 
Предоставляя несколько имен событий, разделенных пробелом, вы приказываете библиотеке jQuery выполнить анонимную функцию при запуске любого
события из списка. В данном случае — при запуске либо события click, либо события keypress. */
/* если вы хотите, чтобы произошло одно событие при щелчке
по элементу и другое — при наведении на этот элемент указателя мыши,
вы можете написать следующий код: */
$('#theElement').on('click', function(){
	// какое-либо интересное действие
});
$('#theElement').on('mouseover', function(){
	// еще какое-нибудь интересное действие
});
/* Вы можете добиться того же результата, передав функции on() объектную константу (см. раздел «Одновременное изменение нескольких
свойств CSS» главы 4), состоящую из имени события, за которой следуют двоеточие и анонимная функция*/
$('#theElement').on({
	'click' : function(){
		// какое-либо интересное действие
	},
	'mouseover' : function(){
		// еще какое-нибудь интересное действие
	};
});


// делегирование событий 
$('ul').on('click', 'li', function(){
	$(this).css('text-decoration': 'line-through');
}); // this здесь li 


next() // находит элемент, который следует непосредственно за текущим элементом
delay() // ожидает определенное количество миллисекунд, прежде чем запускать
stop() // завершает любой анимационный эффект, прежде чем запускать новый и предотвращает создание очереди эффектов (стр.302).

// === функции для отображения и сокрытия элементов 277 ===
show(); // показывает ранее скрытый элемент
hide(); // скрывает видимый элемент
toggle(); // переключает текущее состояние элемента

// === Постепенное появление и исчезновение элементов 279 ===
fadeln(); // показывает скрытый элемент.
fadeOut(); // заставляет элемент исчезать, делая его прозрачным.
fadeToggle(); // сочетает эффекты функций fadeln() и fadeOut().
fadeTo(); // изменяет степень непрозрачности изображения до определенного значения.

// === Скользящие элементы 280 ===
slideDown(); // заставляет скрытый элемент появиться в поле зрения. 
slideUp(); // удаляет элемент из виду
slideToggle(); // применяет функцию slideDown() к элементу, который в данный момент скрыт, а функцию slideUp() — к видимому.

$('.element').hide('slow'); // скрытие 
$('.element').fadeOut('slow'); // медленное исчезновение
/*
ПРИМЕЧАНИЕ
Ключевые слова, используемые для задавания скорости эффекта, — 'fast', 'normal' или ’slow' — соответствуют 200, 400 и 600 миллисекундам. Поэтому код:
$('element').fadeOut('slow');
равнозначен коду:
$('element').fadeOut(600);
*/
$('.gallery').click(function(){
	$(this).find('img').fadeTo(500,.3).fadeTo(250,1);
});
/* функция fadeTo() в качестве аргументов принимает значение длительности и степень непрозрачности. Таким
образом, при выполнении данного программного кода все изображения
будут плавно исчезать, достигая степени непрозрачности 30% в течение
500мс, а затем вновь появляться — достигать 100% степени непрозрачности — в течение 250мс */


// === Анимация 287 ===
animate();

$('.message').animate(
{
	left: '650px';
	opacity: .5;
	fontSize: '24px';
},
	1500,  // длительность анимации 
	'linear' // метод анимации 
);

/* Вы также можете задать свойство относительно его текущего значения, используя операции += или -= как часть настроек анимации. Например, вы хотите анимировать элемент, сдвигая его на 50 пикселов вправо
при каждом щелчке по нему кнопкой мыши. */
$('.move').click(function(){
	$(this).animate(
	{
		left: '+=50px'
	}, 1000);
});


/* === Функция обратного вызова === 
Функция обратного вызова передается большинству эффектов в качестве второго аргумента 
(а функции fadeTo() — в качестве третьего аргумента). */
$('.photo').fadeIn(1000, function() {
	$('.caption').fadeIn(1000);
});

$('.photo').width(0).height(0).css('opacity', 0);
$('.caption').hide();
$('.photo').animate(
	{
		width: '200px',
		height: '100px',
		opacity: 1
	},
	1000,
	function() {
		$('.caption').fadeIn(1000);
	});


// === Форма === 504
val() /*может как задавать, так и считывать значения элементов формы. Если вы вызываете ее без передачи аргументов,
она будет считывать значения; при передаче функции значения она введет его в элемент формы. */



// === Ajax === 632
$.get(url, data, callback); // 653
$.post(url, data, callback);
/* Метод GET подходит для запросов, которые не влияют на структуру базы данных или файлов на
сервере. Другими словами, используйте этот метод, если вам нужно
получить информацию, например, для запроса цены определенного
товара или списка самых популярных продуктов.

Метод POST удобен для отправки данных, изменяющих информацию на сервере,
подобно запросу на удаление файла, обновление базы данных или
добавление в нее новых записей.*/

$.getJSON(url, data, callback); // 674


// === Тернарная операция === 807
var status;
if (login) {
	status='Авторизован';
} else {
	status='Не авторизован';
}

// Базовый формат тернарной операции таков:
(условие) ? A : B
/* В зависимости от результата условия операция возвращает А (если условие истинно (true)) 
или В (если условие ложно (false)). Знак ? стоит перед значением true, тогда как знак «:» предшествует значению false. 
Так, например, приведенный выше код можно переписать следующим образом: */
var status=(login) ? 'Авторизован' : 'Не авторизован';


// === Инструкция-переключатель или операция выбора === 809
if (favoriteColor == 'голубой') {
	message = 'Голубой - это холодный цвет.';
} else if (favoriteColor == 'красный') {
	message = 'Красный - это тёплый цвет.';
} else if (favoriteColor == 'зелёный') {
	message = 'Зелёный - это цвет листьев.';
} else {
	message = 'Что это за цвет?';
}

switch (favoriteColor) {
	case 'голубой':
		message = 'Голубой - это холодный цвет.';
		break;
	case 'красный':
		message = 'Красный - это тёплый цвет.';
		break;
	case 'зелёный':
		message = 'Зелёный - это цвет листьев.';
		break;
	default:
		message = 'Что это за цвет?';
}
